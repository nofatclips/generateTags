// Generated by CoffeeScript 1.6.1

/*
generateTags.js
A JavaScript function that processes plain text or HTML (1st argument, as string)
and produces a keyword frequency hash to facilitate tagging.
Optional second argument: options object, governs the behaviour and output format.
Can produce output suitable for the Wordle.net word cloud generator.

This is free software (free as in free beer), published under the MIT license,
see http://opensource.org/licenses/MIT

This file is generated from its coffeescript source, see generateTags.coffee.md
*/


(function() {
  var caps, defaults, htmlDecode, html_tags, non_word, punctuation_chars, remove_words, stopwords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  defaults = {
    limit: 0,
    blacklist: "",
    ignoreStopwords: true,
    minLength: 0,
    minFrequency: 0,
    ignoreCase: true,
    retainProperNames: true,
    ignorePunctuation: true,
    ignoreNumbers: true,
    ignoreNonTextTags: true,
    outputFormat: 'list'
  };

  stopwords = "a about above after again against all am an and any are aren't as at be because been before being below between both but by can't cannot could couldn't did didn't do does doesn't doing don't down during each few for from further had hadn't has hasn't have haven't having he he'd he'll he's her here here's hers herself him himself his how how's i i'd i'll i'm i've if in into is isn't it it's its itself let's me more most mustn't my myself no nor not of off on once only or other ought our ours ourselves out over own same shan't she she'd she'll she's should shouldn't so some such than that that's the their theirs them themselves then there there's these they they'd they'll they're they've this those through to too under until up very was wasn't we we'd we'll we're we've were weren't what what's when when's where where's which while who who's whom why why's with won't would wouldn't you you'd you'll you're you've your yours yourself yourselves";

  html_tags = "button head script map style audio video canvas svg data";

  punctuation_chars = ".,:;?!¿¡\\/\\[|\\](){}«»#@$%&§£\"+*=<>^`´\\\\\\u2000-\\u2018\\u201a-\\u205f";

  non_word = "\\s" + punctuation_chars;

  caps = "[A-Z\\u00c0-\\u01b5\\u0391-\\u03a9\\u0400-\\u042f\\u10a0-\\u10c5]";

  htmlDecode = function(input) {
    var e;
    if (typeof document === "undefined" || document === null) {
      return input;
    }
    (e = document.createElement('div')).innerHTML = input;
    return e.firstChild.nodeValue;
  };

  remove_words = function(text, word_string) {
    var batch, batches, re, regexes, w, words, x, _i, _len;
    words = word_string.replace(/,/g, ' ').split(/\s+/).sort(function(a, b) {
      return b.length - a.length;
    });
    if (word_string.match(/'/)) {
      words = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = words.length; _i < _len; _i++) {
          w = words[_i];
          _results.push(w.replace(/'/, "['’]"));
        }
        return _results;
      })();
    }
    batches = (function() {
      var _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = Math.floor(words.length / 100); 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push(words.slice(100 * x, 100 * (x + 1)));
      }
      return _results;
    })();
    regexes = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = batches.length; _i < _len; _i++) {
        batch = batches[_i];
        _results.push(new RegExp("([" + non_word + "])(" + (batch.join('|')) + ")(?=[" + non_word + "])", "gi"));
      }
      return _results;
    })();
    text = " " + text;
    for (_i = 0, _len = regexes.length; _i < _len; _i++) {
      re = regexes[_i];
      text = text.replace(re, "$1");
    }
    return text;
  };

  /*
  @param html: a string containing the HTML to be processed
  @param options: the options object, as follows (default values)
    limit: 0                   # maximum number of most frequent words (0: no limit)
    blacklist: ""              # comma- or space separated strings to ignore (e.g. swear words)
                               # in addition to stopwords
    minLength: 0               # ignore shorter words (0: no minimum length)
    minFrequency: 0            # ignore words below a frequency threshold (0: no limit)
    retainProperNames: true    # don't ignore case when you see "Chuck Norris"
    ignoreCase: true           # by default, treat "House" and "house" as the same word
    ignoreStopwords: true      # see list of English stopwords below
    ignorePunctuation: true    # only set this to false if it ¿really? matters to you
    ignoreNumbers:     true    # numbers usually aren't good candidates for key words / tags
    ignoreNonTextTags: true    # ignore <script>, <style>, <img>, <video>, <audio> and friends
    outputFormat: 'list'       # Array, sorted by frequency descending
                               # alternative values:
                               #   'object' ==> {'blah':23,...}
                               #   'wordle' ==> "blah:23\n...", for http://www.wordle.net/advanced
  */


  this.generateTags = function(html, options) {
    var abbrv_candidates, c, candidates, count, freq, n, name, opts, pos, re, re_abbrv, re_candidate, result, str, uniq, uniq_abbrv, w, word, words, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref;
    opts = options || {};
    for (x in defaults) {
      opts[x] = opts[x] === void 0 ? defaults[x] : opts[x];
    }
    if (opts.ignoreNonTextTags) {
      re = new RegExp("<(" + (html_tags.replace(/\s/g, '|')) + ").+?</\\1>", "gi");
      html = html.replace(re, ' ');
    }
    html = html.replace(/<.+?>/g, ' ');
    html = htmlDecode(html);
    if (opts.blacklist !== "") {
      console.log("removing blacklist words...");
    }
    if (opts.blacklist !== "") {
      html = remove_words(html, blacklist);
    }
    html = html.replace(/\s+/g, ' ');
    freq = {};
    if (opts.retainProperNames) {
      for (n = _i = 7; _i >= 2; n = --_i) {
        re_candidate = new RegExp("" + caps + "[^" + non_word + "]+( [^" + non_word + "]+){" + (n - 1) + "}", 'g');
        candidates = html.match(re_candidate);
        uniq = [];
        for (_j = 0, _len = candidates.length; _j < _len; _j++) {
          c = candidates[_j];
          if (__indexOf.call(uniq, c) < 0) {
            uniq.push(c);
          }
        }
        uniq = (function() {
          var _k, _len1, _results;
          _results = [];
          for (_k = 0, _len1 = uniq.length; _k < _len1; _k++) {
            c = uniq[_k];
            if (html.match(new RegExp(c, 'g')).length > 1) {
              _results.push(c);
            }
          }
          return _results;
        })();
        uniq = (function() {
          var _k, _len1, _results;
          _results = [];
          for (_k = 0, _len1 = uniq.length; _k < _len1; _k++) {
            c = uniq[_k];
            if (!html.match(new RegExp(c.slice(0, pos = c.indexOf(' ')) + ("(?!" + (c.slice(pos)) + ")"), 'g'))) {
              _results.push(c);
            }
          }
          return _results;
        })();
        for (_k = 0, _len1 = uniq.length; _k < _len1; _k++) {
          name = uniq[_k];
          re = new RegExp(name, 'g');
          freq[name] = html.match(re).length;
          html = html.replace(re, '');
        }
      }
    }
    re_abbrv = new RegExp("" + caps + "{2,}", 'g');
    abbrv_candidates = html.match(re_abbrv);
    uniq_abbrv = [];
    for (_l = 0, _len2 = abbrv_candidates.length; _l < _len2; _l++) {
      c = abbrv_candidates[_l];
      if (__indexOf.call(uniq_abbrv, c) < 0) {
        uniq_abbrv.push(c);
      }
    }
    _ref = uniq_abbrv.sort(function(a, b) {
      return b.length - a.length;
    });
    for (_m = 0, _len3 = _ref.length; _m < _len3; _m++) {
      x = _ref[_m];
      re = new RegExp(x, 'g');
      if ((count = html.match(re).length) > 1) {
        freq[x] = count;
        html = html.replace(re, '');
      }
    }
    if (opts.ignoreStopwords) {
      html = remove_words(html, stopwords);
    }
    if (opts.ignorePunctuation) {
      html = html.replace(new RegExp("(([" + non_word + "])['’-]|['’-](?![^" + non_word + "])|^['’-])", 'g'), "$2");
      html = html.replace(new RegExp("[" + punctuation_chars + "]", 'g'), ' ');
    }
    if (opts.ignoreNumbers) {
      html = html.replace(/\s\d+\s/gi, ' ');
    }
    html = html.replace(new RegExp("\\s[" + non_word + "]+\\s", 'gi'), ' ');
    if (opts.ignoreCase) {
      html = html.toLowerCase();
    }
    words = html.trim().split(/\s+/);
    for (_n = 0, _len4 = words.length; _n < _len4; _n++) {
      w = words[_n];
      freq[w] || (freq[w] = 0);
      freq[w]++;
    }
    words = (function() {
      var _results;
      _results = [];
      for (word in freq) {
        _results.push(word);
      }
      return _results;
    })();
    if (opts.minLength > 0) {
      words = (function() {
        var _len5, _o, _results;
        _results = [];
        for (_o = 0, _len5 = words.length; _o < _len5; _o++) {
          word = words[_o];
          if (word.length >= opts.minLength) {
            _results.push(word);
          }
        }
        return _results;
      })();
    }
    if (opts.minFrequency > 0) {
      words = (function() {
        var _len5, _o, _results;
        _results = [];
        for (_o = 0, _len5 = words.length; _o < _len5; _o++) {
          word = words[_o];
          if (freq[word] >= opts.minFrequency) {
            _results.push(word);
          }
        }
        return _results;
      })();
    }
    words = words.sort(function(a, b) {
      return freq[b] - freq[a];
    });
    if (opts.limit > 0) {
      words = words.slice(0, opts.limit);
    }
    if (opts.outputFormat === 'list') {
      return words;
    } else {
      result = {};
      for (_o = 0, _len5 = words.length; _o < _len5; _o++) {
        word = words[_o];
        result[word] = freq[word];
      }
      if (opts.outputFormat === 'list') {
        return result;
      } else {
        str = "";
        for (word in result) {
          str += "" + word + ":" + result[word] + "\n";
        }
        return str;
      }
    }
  };

}).call(this);
